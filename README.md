## Результати

| Алгоритм        |Часова складність    | 10       | 20       | 100       | 500        | 1 000    | 10 000
|-----------------|---------------------|----------|----------|-----------|------------|----------|---------
| Timsort(sorted) | O(n*log n)          | 0.000022 | 0.0000024| 0.0000054 | 0.000011   | 0.000016 | 0.000085
| Merge_sort      | O(n*log n)          | 0.00004  | 0.00002  | 0.00014   | 0.00077    | 0.00165  | 0.02156
| insertion_sort  | O(n^2)              | 0.00003  | 0.00001  | 0.00013   | 0.00438    | 0.01892  | 1.95175

## Висновки

Виходячи з отриманих результатів можна зробити наступний висновок:
- найшвидший вид сортування - **sorted** (використовує **timsort**) ніж два інші на цілий порядок, завдяки комбінації сортування злиттям та сортування вставками, які адаптуються до характеристик даних.
- повільнішим ніж **sorted**, але швидшим ніж **merge_sort** з малими масивами (10, 20, 100) є сортування **insertion_sort**.
- найповільнішим з малими масивами (10, 20, 100) є **merge_sort**. А ось з більшими масивами (500, 1000, 10000) він швидше ніж **insertion_sort**.
